// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'channels_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ChannelsState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChannelsStateCopyWith<$Res> {
  factory $ChannelsStateCopyWith(
          ChannelsState value, $Res Function(ChannelsState) then) =
      _$ChannelsStateCopyWithImpl<$Res, ChannelsState>;
}

/// @nodoc
class _$ChannelsStateCopyWithImpl<$Res, $Val extends ChannelsState>
    implements $ChannelsStateCopyWith<$Res> {
  _$ChannelsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ChannelsInitialImplCopyWith<$Res> {
  factory _$$ChannelsInitialImplCopyWith(_$ChannelsInitialImpl value,
          $Res Function(_$ChannelsInitialImpl) then) =
      __$$ChannelsInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ChannelsInitialImplCopyWithImpl<$Res>
    extends _$ChannelsStateCopyWithImpl<$Res, _$ChannelsInitialImpl>
    implements _$$ChannelsInitialImplCopyWith<$Res> {
  __$$ChannelsInitialImplCopyWithImpl(
      _$ChannelsInitialImpl _value, $Res Function(_$ChannelsInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ChannelsInitialImpl implements ChannelsInitial {
  const _$ChannelsInitialImpl();

  @override
  String toString() {
    return 'ChannelsState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ChannelsInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class ChannelsInitial implements ChannelsState {
  const factory ChannelsInitial() = _$ChannelsInitialImpl;
}

/// @nodoc
abstract class _$$FetchPackagesLoadingImplCopyWith<$Res> {
  factory _$$FetchPackagesLoadingImplCopyWith(_$FetchPackagesLoadingImpl value,
          $Res Function(_$FetchPackagesLoadingImpl) then) =
      __$$FetchPackagesLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchPackagesLoadingImplCopyWithImpl<$Res>
    extends _$ChannelsStateCopyWithImpl<$Res, _$FetchPackagesLoadingImpl>
    implements _$$FetchPackagesLoadingImplCopyWith<$Res> {
  __$$FetchPackagesLoadingImplCopyWithImpl(_$FetchPackagesLoadingImpl _value,
      $Res Function(_$FetchPackagesLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FetchPackagesLoadingImpl implements FetchPackagesLoading {
  const _$FetchPackagesLoadingImpl();

  @override
  String toString() {
    return 'ChannelsState.fetchPackagesloading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchPackagesLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) {
    return fetchPackagesloading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) {
    return fetchPackagesloading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchPackagesloading != null) {
      return fetchPackagesloading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) {
    return fetchPackagesloading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) {
    return fetchPackagesloading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchPackagesloading != null) {
      return fetchPackagesloading(this);
    }
    return orElse();
  }
}

abstract class FetchPackagesLoading implements ChannelsState {
  const factory FetchPackagesLoading() = _$FetchPackagesLoadingImpl;
}

/// @nodoc
abstract class _$$FetchPackagesSuccessImplCopyWith<$Res> {
  factory _$$FetchPackagesSuccessImplCopyWith(_$FetchPackagesSuccessImpl value,
          $Res Function(_$FetchPackagesSuccessImpl) then) =
      __$$FetchPackagesSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PackagesModel> packages});
}

/// @nodoc
class __$$FetchPackagesSuccessImplCopyWithImpl<$Res>
    extends _$ChannelsStateCopyWithImpl<$Res, _$FetchPackagesSuccessImpl>
    implements _$$FetchPackagesSuccessImplCopyWith<$Res> {
  __$$FetchPackagesSuccessImplCopyWithImpl(_$FetchPackagesSuccessImpl _value,
      $Res Function(_$FetchPackagesSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? packages = null,
  }) {
    return _then(_$FetchPackagesSuccessImpl(
      null == packages
          ? _value._packages
          : packages // ignore: cast_nullable_to_non_nullable
              as List<PackagesModel>,
    ));
  }
}

/// @nodoc

class _$FetchPackagesSuccessImpl implements FetchPackagesSuccess {
  const _$FetchPackagesSuccessImpl(final List<PackagesModel> packages)
      : _packages = packages;

  final List<PackagesModel> _packages;
  @override
  List<PackagesModel> get packages {
    if (_packages is EqualUnmodifiableListView) return _packages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_packages);
  }

  @override
  String toString() {
    return 'ChannelsState.fetchPackagesSuccess(packages: $packages)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchPackagesSuccessImpl &&
            const DeepCollectionEquality().equals(other._packages, _packages));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_packages));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchPackagesSuccessImplCopyWith<_$FetchPackagesSuccessImpl>
      get copyWith =>
          __$$FetchPackagesSuccessImplCopyWithImpl<_$FetchPackagesSuccessImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) {
    return fetchPackagesSuccess(packages);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) {
    return fetchPackagesSuccess?.call(packages);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchPackagesSuccess != null) {
      return fetchPackagesSuccess(packages);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) {
    return fetchPackagesSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) {
    return fetchPackagesSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchPackagesSuccess != null) {
      return fetchPackagesSuccess(this);
    }
    return orElse();
  }
}

abstract class FetchPackagesSuccess implements ChannelsState {
  const factory FetchPackagesSuccess(final List<PackagesModel> packages) =
      _$FetchPackagesSuccessImpl;

  List<PackagesModel> get packages;
  @JsonKey(ignore: true)
  _$$FetchPackagesSuccessImplCopyWith<_$FetchPackagesSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchPackagesErrorImplCopyWith<$Res> {
  factory _$$FetchPackagesErrorImplCopyWith(_$FetchPackagesErrorImpl value,
          $Res Function(_$FetchPackagesErrorImpl) then) =
      __$$FetchPackagesErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$FetchPackagesErrorImplCopyWithImpl<$Res>
    extends _$ChannelsStateCopyWithImpl<$Res, _$FetchPackagesErrorImpl>
    implements _$$FetchPackagesErrorImplCopyWith<$Res> {
  __$$FetchPackagesErrorImplCopyWithImpl(_$FetchPackagesErrorImpl _value,
      $Res Function(_$FetchPackagesErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$FetchPackagesErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FetchPackagesErrorImpl implements FetchPackagesError {
  const _$FetchPackagesErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'ChannelsState.fetchPackagesError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchPackagesErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchPackagesErrorImplCopyWith<_$FetchPackagesErrorImpl> get copyWith =>
      __$$FetchPackagesErrorImplCopyWithImpl<_$FetchPackagesErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) {
    return fetchPackagesError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) {
    return fetchPackagesError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchPackagesError != null) {
      return fetchPackagesError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) {
    return fetchPackagesError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) {
    return fetchPackagesError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchPackagesError != null) {
      return fetchPackagesError(this);
    }
    return orElse();
  }
}

abstract class FetchPackagesError implements ChannelsState {
  const factory FetchPackagesError(final String error) =
      _$FetchPackagesErrorImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$FetchPackagesErrorImplCopyWith<_$FetchPackagesErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchChannelsLoadingImplCopyWith<$Res> {
  factory _$$FetchChannelsLoadingImplCopyWith(_$FetchChannelsLoadingImpl value,
          $Res Function(_$FetchChannelsLoadingImpl) then) =
      __$$FetchChannelsLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FetchChannelsLoadingImplCopyWithImpl<$Res>
    extends _$ChannelsStateCopyWithImpl<$Res, _$FetchChannelsLoadingImpl>
    implements _$$FetchChannelsLoadingImplCopyWith<$Res> {
  __$$FetchChannelsLoadingImplCopyWithImpl(_$FetchChannelsLoadingImpl _value,
      $Res Function(_$FetchChannelsLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FetchChannelsLoadingImpl implements FetchChannelsLoading {
  const _$FetchChannelsLoadingImpl();

  @override
  String toString() {
    return 'ChannelsState.fetchChannelsLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchChannelsLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) {
    return fetchChannelsLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) {
    return fetchChannelsLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchChannelsLoading != null) {
      return fetchChannelsLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) {
    return fetchChannelsLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) {
    return fetchChannelsLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchChannelsLoading != null) {
      return fetchChannelsLoading(this);
    }
    return orElse();
  }
}

abstract class FetchChannelsLoading implements ChannelsState {
  const factory FetchChannelsLoading() = _$FetchChannelsLoadingImpl;
}

/// @nodoc
abstract class _$$FetchChannelsSuccessImplCopyWith<$Res> {
  factory _$$FetchChannelsSuccessImplCopyWith(_$FetchChannelsSuccessImpl value,
          $Res Function(_$FetchChannelsSuccessImpl) then) =
      __$$FetchChannelsSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ChannelsModel> channels});
}

/// @nodoc
class __$$FetchChannelsSuccessImplCopyWithImpl<$Res>
    extends _$ChannelsStateCopyWithImpl<$Res, _$FetchChannelsSuccessImpl>
    implements _$$FetchChannelsSuccessImplCopyWith<$Res> {
  __$$FetchChannelsSuccessImplCopyWithImpl(_$FetchChannelsSuccessImpl _value,
      $Res Function(_$FetchChannelsSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? channels = null,
  }) {
    return _then(_$FetchChannelsSuccessImpl(
      null == channels
          ? _value._channels
          : channels // ignore: cast_nullable_to_non_nullable
              as List<ChannelsModel>,
    ));
  }
}

/// @nodoc

class _$FetchChannelsSuccessImpl implements FetchChannelsSuccess {
  const _$FetchChannelsSuccessImpl(final List<ChannelsModel> channels)
      : _channels = channels;

  final List<ChannelsModel> _channels;
  @override
  List<ChannelsModel> get channels {
    if (_channels is EqualUnmodifiableListView) return _channels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_channels);
  }

  @override
  String toString() {
    return 'ChannelsState.fetchChannelsSuccess(channels: $channels)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchChannelsSuccessImpl &&
            const DeepCollectionEquality().equals(other._channels, _channels));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_channels));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchChannelsSuccessImplCopyWith<_$FetchChannelsSuccessImpl>
      get copyWith =>
          __$$FetchChannelsSuccessImplCopyWithImpl<_$FetchChannelsSuccessImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) {
    return fetchChannelsSuccess(channels);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) {
    return fetchChannelsSuccess?.call(channels);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchChannelsSuccess != null) {
      return fetchChannelsSuccess(channels);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) {
    return fetchChannelsSuccess(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) {
    return fetchChannelsSuccess?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchChannelsSuccess != null) {
      return fetchChannelsSuccess(this);
    }
    return orElse();
  }
}

abstract class FetchChannelsSuccess implements ChannelsState {
  const factory FetchChannelsSuccess(final List<ChannelsModel> channels) =
      _$FetchChannelsSuccessImpl;

  List<ChannelsModel> get channels;
  @JsonKey(ignore: true)
  _$$FetchChannelsSuccessImplCopyWith<_$FetchChannelsSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchChannelsErrorImplCopyWith<$Res> {
  factory _$$FetchChannelsErrorImplCopyWith(_$FetchChannelsErrorImpl value,
          $Res Function(_$FetchChannelsErrorImpl) then) =
      __$$FetchChannelsErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$FetchChannelsErrorImplCopyWithImpl<$Res>
    extends _$ChannelsStateCopyWithImpl<$Res, _$FetchChannelsErrorImpl>
    implements _$$FetchChannelsErrorImplCopyWith<$Res> {
  __$$FetchChannelsErrorImplCopyWithImpl(_$FetchChannelsErrorImpl _value,
      $Res Function(_$FetchChannelsErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$FetchChannelsErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FetchChannelsErrorImpl implements FetchChannelsError {
  const _$FetchChannelsErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'ChannelsState.fetchChannelsError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchChannelsErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchChannelsErrorImplCopyWith<_$FetchChannelsErrorImpl> get copyWith =>
      __$$FetchChannelsErrorImplCopyWithImpl<_$FetchChannelsErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchPackagesloading,
    required TResult Function(List<PackagesModel> packages)
        fetchPackagesSuccess,
    required TResult Function(String error) fetchPackagesError,
    required TResult Function() fetchChannelsLoading,
    required TResult Function(List<ChannelsModel> channels)
        fetchChannelsSuccess,
    required TResult Function(String error) fetchChannelsError,
  }) {
    return fetchChannelsError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? fetchPackagesloading,
    TResult? Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult? Function(String error)? fetchPackagesError,
    TResult? Function()? fetchChannelsLoading,
    TResult? Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult? Function(String error)? fetchChannelsError,
  }) {
    return fetchChannelsError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchPackagesloading,
    TResult Function(List<PackagesModel> packages)? fetchPackagesSuccess,
    TResult Function(String error)? fetchPackagesError,
    TResult Function()? fetchChannelsLoading,
    TResult Function(List<ChannelsModel> channels)? fetchChannelsSuccess,
    TResult Function(String error)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchChannelsError != null) {
      return fetchChannelsError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ChannelsInitial value) initial,
    required TResult Function(FetchPackagesLoading value) fetchPackagesloading,
    required TResult Function(FetchPackagesSuccess value) fetchPackagesSuccess,
    required TResult Function(FetchPackagesError value) fetchPackagesError,
    required TResult Function(FetchChannelsLoading value) fetchChannelsLoading,
    required TResult Function(FetchChannelsSuccess value) fetchChannelsSuccess,
    required TResult Function(FetchChannelsError value) fetchChannelsError,
  }) {
    return fetchChannelsError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ChannelsInitial value)? initial,
    TResult? Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult? Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult? Function(FetchPackagesError value)? fetchPackagesError,
    TResult? Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult? Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult? Function(FetchChannelsError value)? fetchChannelsError,
  }) {
    return fetchChannelsError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ChannelsInitial value)? initial,
    TResult Function(FetchPackagesLoading value)? fetchPackagesloading,
    TResult Function(FetchPackagesSuccess value)? fetchPackagesSuccess,
    TResult Function(FetchPackagesError value)? fetchPackagesError,
    TResult Function(FetchChannelsLoading value)? fetchChannelsLoading,
    TResult Function(FetchChannelsSuccess value)? fetchChannelsSuccess,
    TResult Function(FetchChannelsError value)? fetchChannelsError,
    required TResult orElse(),
  }) {
    if (fetchChannelsError != null) {
      return fetchChannelsError(this);
    }
    return orElse();
  }
}

abstract class FetchChannelsError implements ChannelsState {
  const factory FetchChannelsError(final String error) =
      _$FetchChannelsErrorImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$FetchChannelsErrorImplCopyWith<_$FetchChannelsErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
